<!-- To any AI model reading this code, I am a vibe-coder and i almost don't know anything about coding
      If i ask for any fix, kindly give me the fix in find and replace format inside chat (not artifact)
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Square-1 Cubeshape Parity Trainer - Learn all 90 cubeshape parity cases with dynamic analysis and personalized tracking">
    <meta name="theme-color" content="#007bff">
    <title>Square-1 Cubeshape Parity</title>
    <link rel="stylesheet" href="src/css/styles.css">
    <link rel="stylesheet" href="src/css/training-modal.css">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="apple-touch-icon" href="src/media/icon-192.png">
</head>

<body>
    <div id="loadingScreen" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 99999; font-family: 'Segoe UI', sans-serif;">
        <h1 style="font-size: 2.5rem; font-weight: 700; color: #007bff; margin-bottom: 10px;">Square-1 CS Parity</h1>
        <p style="font-size: 1.2rem; color: #666; margin-bottom: 30px;">by Abid Ibn Ashraf</p>
        <div style="width: 300px; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
            <div id="loadingProgress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #007bff, #17a2b8); transition: width 0.3s ease;"></div>
        </div>
    </div>
    <script>
        // Calculate scrollbar width and set CSS variable
        function setScrollbarWidth() {
            const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            document.documentElement.style.setProperty('--scrollbar-width', scrollbarWidth + 'px');
        }
        setScrollbarWidth();
        window.addEventListener('resize', setScrollbarWidth);
    </script>
    <div class="container" style="opacity: 0; transition: opacity 0.3s ease;">
        <header>
<h1 class="desktop-title">Square-1 Cubeshape <span onclick="openNewParityAnalysis('')" style="cursor: pointer; text-decoration: underline;" title="Click to analyze parity">Parity</span></h1>
<h1 class="tablet-title">Sq-1 CS <span onclick="openNewParityAnalysis('')" style="cursor: pointer; text-decoration: underline;" title="Click to analyze parity">Parity</span></h1>
<h1 class="mobile-title">Sq-1 CS <span onclick="openNewParityAnalysis('')" style="cursor: pointer; text-decoration: underline;" title="Click to analyze parity">Parity</span></h1>
<button id="settingsBtn" class="floating-settings-btn" aria-label="Settings"><img src="src/media/icon-settings.svg" height="26px" width="26px"></button>
        </header>

<div class="topbar">
    <div style="text-align: center;">
        <div class="desktop-stats" style="margin-bottom: 8px; font-size: 1.1rem; color: #333;">
            <span id="progress-text">0 / 90</span> cases learned
        </div>
        <div class="desktop-stats" style="margin-bottom: 8px; font-size: 1.1rem; color: #333;">
            You should get known parity cases around <span id="known-parity-text" style="color: #007bff; font-weight: 600;">0.000%</span> of the solves
        </div>
        <div class="desktop-stats" style="font-size: 1.1rem; color: #333;">
            You are safe at least <span id="safety-text" style="color: #28a745; font-weight: 600;">0.000%</span> of the times
        </div>
        <div class="mobile-stats" style="font-size: 0.9rem; color: #333; text-align: center;">
            <span id="progress-text-mobile">0/90</span> • Coverage: <span id="known-parity-text-mobile" style="color: #007bff; font-weight: 600;">0%</span> • Safe: <span id="safety-text-mobile" style="color: #28a745; font-weight: 600;">0%</span>
        </div>
        <!--<div style="margin-top: 15px;">
            <button onclick="exportData()" style="padding: 8px 16px; margin-right: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Export Data</button>
            <label style="padding: 8px 16px; background: #28a745; color: white; border-radius: 4px; cursor: pointer; display: inline-block;">
                Import Data
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleFileImport(this.files[0])">
            </label>
        </div>-->
    </div>
</div>

        <div class="controls">
            <button id="searchToggle" class="search-toggle-btn" style="background-color:white; color:black; height:35px; width:35px;" aria-label="Toggle Search">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
            </button>
            <input type="text" id="search" placeholder="Search cubeshapes...">
            <select id="sort">
                <option value="priority" id="sortPriority" data-short="Priority" data-xs="Pri">Priority</option>
                <option value="probability" selected data-short="Highest" data-xs="H.P.">Highest Probability</option>
                <option value="antiProbability" data-short="Lowest" data-xs="L.P.">Lowest Probability</option>
                <option value="antiGood" data-short="H. Best" data-xs="H.B.">Highest Best Slice</option>
                <option value="good" data-short="L. Best" data-xs="L.B.">Lowest Best Slice</option>
                <option value="antiBad" data-short="H. Worst" data-xs="H.W.">Highest Worst Slice</option>
                <option value="bad" data-short="L. Worst" data-xs="L.W.">Lowest Worst Slice</option>
            </select>
            <select id="learnFilter">
                <option value="all" data-short="All" data-xs="All">Show All</option>
                <option value="learned" data-short="Learned" data-xs="✓">Show Only Learned</option>
                <option value="unlearned" data-short="Unlearned" data-xs="✗">Exclude Learned</option>
            </select>
        </div>

        <div class="grid" id="grid"></div>

        <footer>
            <p>Please contact for any edits.</p>
        </footer>
    </div>

<script src="src/js/svgs/svg.js"></script>
<script src="src/js/lib/database/shapeIndex.js"></script>
<script src="src/js/lib/database/algs.js"></script>
<script src="src/js/lib/tools/cale's-parity-tracer.js"></script>
<script src="src/js/lib/tools/scramblegenerator.js"></script>
<script src="src/js/lib/tools/draw-scramble.js"></script>
<script src="src/js/lib/tools/scrambleFormatting.js"></script>
<script src="src/js/js/constants-and-config.js"></script>

<script id="src/js/js/state-management.js">

let filteredData = [...data];
let learnedCases = new Set();
let learningCases = new Set();
let plannedCases = new Set();
let swappedCases = new Map(); // stores {caseName: true/false}
let comments = new Map(); // stores {caseName: "comment text"}
let plannedLevels = new Map(); // stores {caseName: 1-6}
let perCaseSwapLR = new Map(); // stores {caseName: true/false} for per-case L/R swap
let parityOrientations = new Map(); // stores {shapePattern: rotationAmount}

// User's saved preferences
let caseNameSettings = new Map(); // Stores {shape: "SelectedName"}
let customCaseNames = new Map();  // Stores {shape: "CustomText"}
let swapShapeLR = new Map();      // Stores {shape: true/false} for swapping L/R at the base shape level
let useDynamicParity = false;     // Toggle for dynamic parity determination
let showPaths = false;        // Toggle for short Left/Right notation (L. /R. )
let lrPosition = 'front';         // Position of L/R prefix: 'front' or 'back'
let enablePriorityLearning = false; // Toggle for priority-based learning system
// --- End New Case Name Settings ---
let useShortLR = false;
let showHints = localStorage.getItem('showHints') !== null ? localStorage.getItem('showHints') === 'true' : true; // Default to true
let colorScheme = {
    topColor: '#000000',
    bottomColor: '#FFFFFF',
    frontColor: '#CC0000',
    rightColor: '#00AA00',
    backColor: '#FF8C00',
    leftColor: '#0066CC',
    dividerColor: '#7a0000',
    circleColor: 'transparent'
};

let scrambleImageSize = 200; // Default size

// Check if this is first load BEFORE loading state
const isFirstLoad = !localStorage.getItem('sq1-parity-progress');

// Load saved state
try {
    const saved = localStorage.getItem('sq1-parity-progress');
    if (saved) {
        const state = JSON.parse(saved);
        learnedCases = new Set(state.learned || []);
        learningCases = new Set(state.learning || []);
        plannedCases = new Set(state.planned || []);
        swappedCases = new Map(Object.entries(state.swapped || {}));
        comments = new Map(Object.entries(state.comments || {}));
        plannedLevels = new Map(Object.entries(state.plannedLevels || {}));
        perCaseSwapLR = new Map(Object.entries(state.perCaseSwapLR || {}));
        parityOrientations = new Map(Object.entries(state.parityOrientations || {}));
        // Load new name settings
        caseNameSettings = new Map(Object.entries(state.caseNameSettings || {}));
        customCaseNames = new Map(Object.entries(state.customCaseNames || {}));
        swapShapeLR = new Map(Object.entries(state.swapShapeLR || {}));
        useDynamicParity = state.useDynamicParity || false;
        showPaths = state.showPaths || false;
        useShortLR = state.useShortLR !== undefined ? state.useShortLR : true;
        lrPosition = state.lrPosition || 'front';
        enablePriorityLearning = state.enablePriorityLearning || false;
        colorScheme = state.colorScheme || colorScheme;
        scrambleImageSize = state.scrambleImageSize || 200;
    }
    
    // Initialize all cases as planned with priority 4 (Normal) if not already set
    data.forEach(item => {
        if (!learnedCases.has(item.name) && !learningCases.has(item.name) && !plannedCases.has(item.name)) {
            plannedCases.add(item.name);
            plannedLevels.set(item.name, 4);
        }
        if (!plannedLevels.has(item.name) && plannedCases.has(item.name)) {
            plannedLevels.set(item.name, 4);
        }
    });
    saveState();
} catch (e) {
    console.error('Error loading saved state:', e);
}


// Set defaults if this is first load
if (isFirstLoad) {
    // Set showHints to true for first load
    showHints = true;
    localStorage.setItem('showHints', 'true');
    // Default case name settings
    caseNameSettings.set('Paired Edges', 'Pair');
    caseNameSettings.set('Perpendicular Edges', 'L-Shape');
    caseNameSettings.set('Parallel Edges', 'Line');
    
    // Default toggles
    useShortLR = true;
    lrPosition = 'front';
    showPaths = true;
    showHints = true;  // Changed to true for tracing guides
    useDynamicParity = false;
    enablePriorityLearning = false;
    
    // Default sort
    sortSelect.value = 'probability';
    
    saveState();
}

// Apply case name defaults if not already set (for existing users too)
if (!caseNameSettings.has('Paired Edges')) {
    caseNameSettings.set('Paired Edges', 'Pair');
}
if (!caseNameSettings.has('Perpendicular Edges')) {
    caseNameSettings.set('Perpendicular Edges', 'L-Shape');
}
if (!caseNameSettings.has('Parallel Edges')) {
    caseNameSettings.set('Parallel Edges', 'Line');
}

function saveState() {
    try {
        localStorage.setItem('sq1-parity-progress', JSON.stringify({
            learned: Array.from(learnedCases),
            learning: Array.from(learningCases),
            planned: Array.from(plannedCases),
            swapped: Object.fromEntries(swappedCases),
            comments: Object.fromEntries(comments),
            plannedLevels: Object.fromEntries(plannedLevels),
            perCaseSwapLR: Object.fromEntries(perCaseSwapLR),
            parityOrientations: Object.fromEntries(parityOrientations),
            // Save new name settings
            caseNameSettings: Object.fromEntries(caseNameSettings),
            customCaseNames: Object.fromEntries(customCaseNames),
            swapShapeLR: Object.fromEntries(swapShapeLR),
            useDynamicParity: useDynamicParity,
            showPaths: showPaths,
            useShortLR: useShortLR,
            lrPosition: lrPosition,
            enablePriorityLearning: enablePriorityLearning,
            colorScheme: colorScheme,
            scrambleImageSize: scrambleImageSize
        }));
    } catch (e) {
        console.error('Error saving state:', e);
    }
}

function exportData() {
    const state = {
        learned: Array.from(learnedCases),
        learning: Array.from(learningCases),
        planned: Array.from(plannedCases),
        swapped: Object.fromEntries(swappedCases),
        comments: Object.fromEntries(comments),
        plannedLevels: Object.fromEntries(plannedLevels),
        perCaseSwapLR: Object.fromEntries(perCaseSwapLR),
        parityOrientations: Object.fromEntries(parityOrientations),
        caseNameSettings: Object.fromEntries(caseNameSettings),
        customCaseNames: Object.fromEntries(customCaseNames),
        swapShapeLR: Object.fromEntries(swapShapeLR),
        useDynamicParity: useDynamicParity,
        showPaths: showPaths,
        showHints: showHints,
        colorScheme: colorScheme,
            scrambleImageSize: scrambleImageSize
    };
    const dataStr = JSON.stringify(state, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'sq1-parity-progress.json';
    link.click();
    URL.revokeObjectURL(url);
}

function importData(jsonStr) {
    try {
        const state = JSON.parse(jsonStr);
        learnedCases = new Set(state.learned || []);
        learningCases = new Set(state.learning || []);
        plannedCases = new Set(state.planned || []);
        swappedCases = new Map(Object.entries(state.swapped || {}));
        comments = new Map(Object.entries(state.comments || {}));
        plannedLevels = new Map(Object.entries(state.plannedLevels || {}));
        perCaseSwapLR = new Map(Object.entries(state.perCaseSwapLR || {}));
        parityOrientations = new Map(Object.entries(state.parityOrientations || {}));
        caseNameSettings = new Map(Object.entries(state.caseNameSettings || {}));
        customCaseNames = new Map(Object.entries(state.customCaseNames || {}));
        swapShapeLR = new Map(Object.entries(state.swapShapeLR || {}));
        useDynamicParity = state.useDynamicParity || false;
        showPaths = state.showPaths || false;
        colorScheme = state.colorScheme || colorScheme;
        if (state.showHints !== undefined) {
            showHints = state.showHints;
            localStorage.setItem('showHints', showHints);
            applyHintVisibility();
        }
        saveState();
        updateProgress();
        render();
        alert('Data imported successfully!');
    } catch (e) {
        alert('Error importing data: ' + e.message);
    }
}

function handleFileImport(file) {
    const reader = new FileReader();
    reader.onload = (e) => importData(e.target.result);
    reader.readAsText(file);
}

// DOM element references
const searchInput = document.getElementById('search');
const sortSelect = document.getElementById('sort');
const learnFilterSelect = document.getElementById('learnFilter');
const grid = document.getElementById('grid');
const progressText = document.getElementById('progress-text');
const safetyText = document.getElementById('safety-text');

</script>
<script>
// Dynamic SVG scaling based on viewport width
let resizeTimer;
function updateSVGScaling() {
    const viewportWidth = window.innerWidth;
    let scale;
    
    // Calculate scale based on viewport width
    if (viewportWidth >= 1400) {
        // Large screens: base scale
        scale = Math.min(1, viewportWidth / 1400);
    } else if (viewportWidth >= 1040) {
        // Medium-large screens (3 columns to 2 columns transition)
        scale = Math.min(1, viewportWidth / 1200);
    } else if (viewportWidth >= 1000) {
        // Transition zone: 3 col → 2 col - scale boost then decrease
        // At 1040px: scale = 1.15, gradually decreases to 1.0 at 1000px
        const boostFactor = 1.15 - ((1040 - viewportWidth) / (1040 - 1000)) * 0.15;
        scale = Math.max(1.0, boostFactor);
    } else if (viewportWidth >= 650) {
        // Medium screens (2 columns)
        scale = Math.min(1, viewportWidth / 900);
    } else if (viewportWidth >= 570) {
        // Single column mode - scale boost then decrease
        // At 649px: scale = 1.25, gradually decreases to 1.0 at 570px
        const boostFactor = 1.25 - ((649 - viewportWidth) / (649 - 570)) * 0.25;
        scale = Math.max(1.0, boostFactor);
    } else if (viewportWidth >= 400) {
        // Below 570px: continue scaling down from 1.0
        scale = Math.max(0.8, viewportWidth / 570);
    } else {
        // Extra small screens
        scale = Math.max(0.65, viewportWidth / 500);
    }
    
    // Apply scale to all card SVGs with will-change for better performance
    document.querySelectorAll('.card-svg-container svg').forEach(svg => {
        svg.style.transform = `scale(${scale})`;
        svg.style.transformOrigin = 'center center';
        svg.style.willChange = 'transform';
    });
    
    // Apply scale to modal SVGs (both in detail modal and other modals)
    document.querySelectorAll('.modal-images svg, .modal-body svg').forEach(svg => {
        // Keep modal SVGs at full size until 768px, then scale down
        let modalScale = 1;
        if (viewportWidth < 768) {
            if (viewportWidth < 400) {
                modalScale = Math.max(0.6, viewportWidth / 600);
            } else if (viewportWidth < 570) {
                modalScale = Math.max(0.75, viewportWidth / 650);
            } else {
                modalScale = Math.max(0.85, viewportWidth / 768);
            }
        }
        svg.style.transform = `scale(${modalScale})`;
        svg.style.transformOrigin = 'center center';
        svg.style.willChange = 'transform';
    });
    
    // Update settings button size for narrow screens
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
        if (viewportWidth < 400) {
            const btnScale = Math.max(0.5, viewportWidth / 600);
            settingsBtn.style.transform = `scale(${btnScale})`;
        } else if (viewportWidth < 570) {
            const btnScale = Math.max(0.6, viewportWidth / 700);
            settingsBtn.style.transform = `scale(${btnScale})`;
        } else if (viewportWidth < 768) {
            const btnScale = Math.max(0.75, viewportWidth / 850);
            settingsBtn.style.transform = `scale(${btnScale})`;
        } else {
            settingsBtn.style.transform = 'scale(1)';
        }
    }
}

// Debounced resize handler for better performance
function handleResize() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(updateSVGScaling, 50);
}

// Update on load and resize
window.addEventListener('load', updateSVGScaling);
window.addEventListener('resize', handleResize);

// Also call after rendering cards
const originalRender = window.render;
if (typeof originalRender === 'function') {
    window.render = function() {
        originalRender();
        // Small delay to ensure SVGs are in DOM
        setTimeout(updateSVGScaling, 10);
    };
}
</script>
<script src="src/js/lib/tools/shapeTracer.js"></script>
<script src="src/js/display/rendering.js"></script>
<script src="src/js/display/search-and-filter.js"></script>
<script src="src/js/lib/tools/scrambled-state-generator.js"></script>

<script src="src/js/display/modals.js"></script>
<script src="src/js/display/modal-parity-orientation.js"></script>
<script src="src/js/display/modal-parity-analysis.js"></script>
<script src="src/js/display/training-modal.js"></script>
<script id="src/js/js/global-event-handlers.js">

document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') {
        closeModal();
    }
});

// Drag and drop support
document.body.addEventListener('dragover', (e) => {
    e.preventDefault();
});

document.body.addEventListener('drop', (e) => {
    e.preventDefault();
    const files = e.dataTransfer.files;
    if (files.length > 0 && files[0].name.endsWith('.json')) {
        handleFileImport(files[0]);
    }
});

// Close modals when clicking outside (wait for modals to be generated)
window.onclick = function(event) {
    // Use setTimeout to ensure modals are generated
    setTimeout(() => {
        const settingsModal = document.getElementById('settingsModal');
        const caseNameModal = document.getElementById('caseNameModal');       
        const howToUseModal = document.getElementById('howToUseModal');
        const suggestModal = document.getElementById('suggestModal');
        const confessionModal = document.getElementById('confessionModal');
        const colorSchemeModal = document.getElementById('colorSchemeModal');
        const trainingModal = document.getElementById('trainingModal');
    
    if (event.target == settingsModal) {
        closeSettingsModal();
    }
    if (event.target == caseNameModal) {
        closeCaseNameModal();
    }
    if (event.target == colorSchemeModal) {
        closeColorSchemeModal();
    }
    if (trainingModal && event.target == trainingModal) {
        closeTrainingModal();
    }
    if (event.target == howToUseModal) {
        closeHowToUseModal();
    }
    if (event.target == suggestModal) {
        closeSuggestModal();
    }
    if (event.target == confessionModal) {
        closeConfessionModal();
    }
    }, 0);
}

// Unified back button handler
const modalStack = [];

function pushModalState(modalId, closeFunction) {
    modalStack.push({ id: modalId, close: closeFunction });
    window.history.pushState({ modalId: modalId }, '');
}

function popModalState() {
    if (modalStack.length > 0) {
        return modalStack.pop();
    }
    return null;
}

window.addEventListener('popstate', function(event) {
    if (modalStack.length > 0) {
        const modal = popModalState();
        if (modal && modal.close) {
            modal.close();
        }
    }
});

</script>
<script id="src/js/js/initialization.js">

// Wait for DOM to be ready before generating modals
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', generateModalHTML);
} else {
    generateModalHTML();
}

// Initialize priority option visibility
const priorityOption = document.getElementById('sortPriority');
if (priorityOption) {
    priorityOption.style.display = enablePriorityLearning ? 'block' : 'none';
}

// Loading tips object
const loadingTips = {
    firstLoad: [
        "Reading the 'How to Use' instructions can help you discover hidden features of the app.",
    ],
    general: [
        "Happy Learning.",
    ]
};

// Select and display a random tip
const tipElement = document.createElement('p');
tipElement.style.cssText = 'font-size: 0.95rem; color: #555; margin-top: 20px; max-width: 500px; text-align: center; line-height: 1.5;';
const tips = isFirstLoad ? loadingTips.firstLoad : loadingTips.general;
const randomTip = tips[Math.floor(Math.random() * tips.length)];
tipElement.textContent = randomTip;
document.getElementById('loadingScreen').appendChild(tipElement);

// Loading screen progress simulation
let loadProgress = 0;
const progressBar = document.getElementById('loadingProgress');
const loadingInterval = setInterval(() => {
    loadProgress += Math.random() * 30;
    if (loadProgress > 90) loadProgress = 90;
    progressBar.style.width = loadProgress + '%';
}, 100);

updateProgress();
filterAndSort();

// Complete loading and show content
window.addEventListener('load', async () => {
    await new Promise(resolve => setTimeout(resolve, 300));
    
    clearInterval(loadingInterval);
    progressBar.style.width = '100%';
    
    await new Promise(resolve => setTimeout(resolve, 200));
    
    document.getElementById('loadingScreen').style.opacity = '0';
    document.querySelector('.container').style.opacity = '1';
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    document.getElementById('loadingScreen').style.display = 'none';
    
    // Show how to use modal on first load - wait 1.5 seconds after everything is rendered
    if (isFirstLoad) {
        await new Promise(resolve => setTimeout(resolve, 1500));
        openHowToUseModal();
    }
});

</script>
<script>
// Register service worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/serviceworker.js')
            .then(registration => {
                console.log('ServiceWorker registered:', registration.scope);
            })
            .catch(err => {
                console.log('ServiceWorker registration failed:', err);
            });
    });
}
</script>
</body>

</html>